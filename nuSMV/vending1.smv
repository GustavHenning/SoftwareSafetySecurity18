MODULE main
VAR
  choice:  boolean;
  payment: boolean;
  acc_payment: boolean;
  state:   { ready, expect_payment, dispense_item };
  n_items: 0..10;

ASSIGN
  init (state) := ready;
  next (state) := case
		    state = ready          & choice:  expect_payment;
		    state = expect_payment & acc_payment: dispense_item;
		    state = expect_payment & !choice: ready;
		    state = dispense_item:	      ready;
		    TRUE:                             state;
  esac;
  next(n_items) := case		    state = dispense_item & n_items > 0: n_items - 1;		    TRUE: n_items;  esac;

  init (acc_payment) := FALSE;
  next (acc_payment) := (state = expect_payment & payment & choice & n_items > 0);

DEFINE
  release_item := (state = dispense_item);

LTLSPEC
  G(acc_payment -> F release_item);
LTLSPEC
  G( n_items >= 0);

/-- ERROR TRACE

-- specification  G (acc_payment ->  F release_item)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample 
Trace Type: Counterexample 
  -> State: 1.1 <- This is the initial state : Nobody has done anything.
    choice = FALSE
    payment = FALSE
    acc_payment = FALSE
    state = ready
    release_item = FALSE
  -> State: 1.2 <- We select a product 
    choice = TRUE
  -> State: 1.3 <- We do the payment but we cancel the choice in the same time
    choice = FALSE
    payment = TRUE
    state = expect_payment
  -> State: 1.4 <- The state comes back in « ready » because of the case expect_payment & !choice and the item is never dispensed
    payment = FALSE
    acc_payment = TRUE
    state = ready
  -- Loop starts here
  -> State: 1.5 <- As we are in the state ready, it loops
    acc_payment = FALSE
  -> State: 1.6 <-
--/ 